<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìš”ë¦¬ ì•„ì´í…œ ìˆ˜ì§‘ ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        canvas {
            display: block;
        }

        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            pointer-events: none;
        }

        #scoreBoard {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 250px;
        }

        .playerScore {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .playerName {
            font-weight: bold;
            font-size: 16px;
        }

        .score {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            color: white;
            min-width: 200px;
        }

        #controls h3 {
            margin-bottom: 10px;
            color: #ffd700;
        }

        #controls p {
            margin: 5px 0;
            font-size: 14px;
        }

        #gameTitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            z-index: 1000;
        }

        #gameTitle h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameTitle p {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #startButton {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            transition: background 0.3s;
        }

        #startButton:hover {
            background: #45a049;
        }

        #winnerMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            z-index: 1000;
        }

        #winnerMessage h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #ffd700;
        }

        #winnerMessage p {
            font-size: 20px;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- ê²Œì„ UI -->
    <div id="gameUI">
        <!-- ì ìˆ˜íŒ -->
        <div id="scoreBoard">
            <div class="playerScore" id="player1Score">
                <span class="playerName" style="color: #ff6b6b;">ğŸ§‘â€ğŸ³ Player 1</span>
                <span class="score">0</span>
            </div>
            <div class="playerScore" id="player2Score">
                <span class="playerName" style="color: #4ecdc4;">ğŸ§‘â€ğŸ³ Player 2</span>
                <span class="score">0</span>
            </div>
            <div class="playerScore" id="player3Score">
                <span class="playerName" style="color: #95e1d3;">ğŸ§‘â€ğŸ³ Player 3</span>
                <span class="score">0</span>
            </div>
        </div>

        <!-- ì¡°ì‘ë²• -->
        <div id="controls">
            <h3>âŒ¨ï¸ Controls</h3>
            <p>ğŸ”´ Player 1: W, A, S, D</p>
            <p>ğŸ”µ Player 2: Arrow Keys</p>
            <p>ğŸŸ¢ Player 3: I, J, K, L</p>
            <hr style="margin: 10px 0; border-color: rgba(255,255,255,0.3);">
            <p>ğŸ¯ Target: 100 points</p>
        </div>
    </div>

    <!-- ì‹œì‘ í™”ë©´ -->
    <div id="gameTitle">
        <h1>ğŸ³ ìš”ë¦¬ ì•„ì´í…œ ìˆ˜ì§‘ ê²Œì„</h1>
        <p>3ëª…ì˜ ìš”ë¦¬ì‚¬ê°€ ì•„ì´í…œì„ ìˆ˜ì§‘í•˜ëŠ” ê²Œì„ì…ë‹ˆë‹¤!</p>
        <p>100ì ì„ ë¨¼ì € ë‹¬ì„±í•˜ë©´ ìŠ¹ë¦¬!</p>
        <button id="startButton">ê²Œì„ ì‹œì‘</button>
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

    <script>
        // ========== ê²Œì„ ìƒíƒœ ==========
        const gameState = {
            players: [],
            items: [],
            walls: [],
            isRunning: false,
            isStarted: false
        };

        // í‚¤ ì…ë ¥ ìƒíƒœ
        const keys = {};

        // ì•„ì´í…œ íƒ€ì… ì •ì˜
        const itemTypes = [
            { type: 'tomato', color: 0xff6347, points: 10, emoji: 'ğŸ…' },
            { type: 'onion', color: 0xffd700, points: 15, emoji: 'ğŸ§…' },
            { type: 'carrot', color: 0xff8c00, points: 20, emoji: 'ğŸ¥•' },
            { type: 'lettuce', color: 0x90ee90, points: 12, emoji: 'ğŸ¥¬' }
        ];

        // ëª©í‘œ ì ìˆ˜
        const TARGET_SCORE = 100;

        // ========== Three.js ê¸°ë³¸ ì„¤ì • ==========
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

        // ì¹´ë©”ë¼ ì„¤ì • (íƒ‘ë·°)
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 25, 15);
        camera.lookAt(0, 0, 0);

        // ë Œë”ëŸ¬ ì„¤ì •
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // ========== ì¡°ëª… ì„¤ì • ==========
        function addLights() {
            // í™˜ê²½ê´‘
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // ë°©í–¥ê´‘ (ê·¸ë¦¼ì)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
        }

        // ========== ë§µ ìƒì„± ==========
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: 0xe0e0e0,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true;
            scene.add(floor);

            // ì²´í¬ë¬´ëŠ¬ íŒ¨í„´
            const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);
        }

        function createWall(x, y, z, width, height, depth) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.7
            });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);

            gameState.walls.push(wall);
            return wall;
        }

        function createBoundaryWalls() {
            const wallHeight = 2;
            const wallThickness = 0.5;
            const mapSize = 20;

            // 4ê°œì˜ ê²½ê³„ ë²½
            createWall(0, wallHeight/2, -mapSize/2, mapSize, wallHeight, wallThickness);
            createWall(0, wallHeight/2, mapSize/2, mapSize, wallHeight, wallThickness);
            createWall(-mapSize/2, wallHeight/2, 0, wallThickness, wallHeight, mapSize);
            createWall(mapSize/2, wallHeight/2, 0, wallThickness, wallHeight, mapSize);
        }

        function createObstacles() {
            // ì¤‘ì•™ ì¹´ìš´í„°
            createWall(0, 1, 0, 4, 2, 2);

            // ì™¼ìª½ ìœ„ í…Œì´ë¸”
            createWall(-5, 0.5, -5, 2, 1, 2);

            // ì˜¤ë¥¸ìª½ ì•„ë˜ í…Œì´ë¸”
            createWall(5, 0.5, 5, 2, 1, 2);
        }

        // ========== í”Œë ˆì´ì–´ ìƒì„± ==========
        function createPlayer(x, z, color, controls, playerNum) {
            // í”Œë ˆì´ì–´ ëª¸í†µ (ì›ê¸°ë‘¥)
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.set(x, 0.5, z);
            body.castShadow = true;
            scene.add(body);

            // ìš”ë¦¬ì‚¬ ëª¨ì (ì›ë¿”)
            const hatGeometry = new THREE.ConeGeometry(0.6, 0.8, 16);
            const hatMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3
            });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.set(x, 1.4, z);
            hat.castShadow = true;
            scene.add(hat);

            // í”Œë ˆì´ì–´ ë°ì´í„°
            const player = {
                body: body,
                hat: hat,
                position: { x: x, z: z },
                speed: 0.15,
                score: 0,
                color: color,
                controls: controls,
                velocity: { x: 0, z: 0 },
                playerNum: playerNum
            };

            gameState.players.push(player);
            return player;
        }

        function createPlayers() {
            // í”Œë ˆì´ì–´ 1 (ë¹¨ê°•) - WASD
            createPlayer(-7, -7, 0xff6b6b, {
                up: 'w', down: 's', left: 'a', right: 'd'
            }, 1);

            // í”Œë ˆì´ì–´ 2 (íŒŒë‘) - í™”ì‚´í‘œ
            createPlayer(7, -7, 0x4ecdc4, {
                up: 'arrowup', down: 'arrowdown',
                left: 'arrowleft', right: 'arrowright'
            }, 2);

            // í”Œë ˆì´ì–´ 3 (ì´ˆë¡) - IJKL
            createPlayer(0, 7, 0x95e1d3, {
                up: 'i', down: 'k', left: 'j', right: 'l'
            }, 3);
        }

        // ========== í‚¤ë³´ë“œ ì…ë ¥ ==========
        window.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
        });

        // ========== í”Œë ˆì´ì–´ ì…ë ¥ ì²˜ë¦¬ ==========
        function handlePlayerInput(player) {
            let moveX = 0;
            let moveZ = 0;

            if (keys[player.controls.up]) moveZ -= 1;
            if (keys[player.controls.down]) moveZ += 1;
            if (keys[player.controls.left]) moveX -= 1;
            if (keys[player.controls.right]) moveX += 1;

            // ëŒ€ê°ì„  ì´ë™ ì†ë„ ì •ê·œí™”
            if (moveX !== 0 && moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
            }

            player.velocity.x = moveX * player.speed;
            player.velocity.z = moveZ * player.speed;
        }

        // ========== ì¶©ëŒ ê°ì§€ ==========
        function checkWallCollision(x, z) {
            const playerRadius = 0.5;

            for (let wall of gameState.walls) {
                const wallBox = new THREE.Box3().setFromObject(wall);

                const playerBox = new THREE.Box3(
                    new THREE.Vector3(x - playerRadius, 0, z - playerRadius),
                    new THREE.Vector3(x + playerRadius, 1, z + playerRadius)
                );

                if (wallBox.intersectsBox(playerBox)) {
                    return true;
                }
            }

            return false;
        }

        // ========== í”Œë ˆì´ì–´ ì—…ë°ì´íŠ¸ ==========
        function updatePlayer(player) {
            handlePlayerInput(player);

            const newX = player.position.x + player.velocity.x;
            const newZ = player.position.z + player.velocity.z;

            if (!checkWallCollision(newX, newZ)) {
                player.position.x = newX;
                player.position.z = newZ;

                player.body.position.x = newX;
                player.body.position.z = newZ;
                player.hat.position.x = newX;
                player.hat.position.z = newZ;
            }
        }

        function updatePlayers() {
            gameState.players.forEach(player => {
                updatePlayer(player);
            });
        }

        // ========== ì•„ì´í…œ ìƒì„± ==========
        function createItem(x, z, itemType) {
            const geometry = new THREE.SphereGeometry(0.3, 16, 16);
            const material = new THREE.MeshStandardMaterial({
                color: itemType.color,
                emissive: itemType.color,
                emissiveIntensity: 0.3,
                roughness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, 0.3, z);
            mesh.castShadow = true;
            scene.add(mesh);

            const item = {
                mesh: mesh,
                position: { x: x, z: z },
                type: itemType.type,
                points: itemType.points,
                collected: false
            };

            gameState.items.push(item);
            return item;
        }

        function spawnRandomItem() {
            const mapSize = 18;
            let x, z;
            let validPosition = false;
            let attempts = 0;

            while (!validPosition && attempts < 50) {
                x = (Math.random() - 0.5) * mapSize;
                z = (Math.random() - 0.5) * mapSize;

                if (!checkWallCollision(x, z)) {
                    validPosition = true;
                }
                attempts++;
            }

            if (validPosition) {
                const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                createItem(x, z, randomType);
            }
        }

        function createInitialItems(count) {
            for (let i = 0; i < count; i++) {
                spawnRandomItem();
            }
        }

        function animateItems() {
            const time = Date.now() * 0.001;

            gameState.items.forEach((item, index) => {
                if (!item.collected) {
                    item.mesh.rotation.y += 0.02;
                    item.mesh.position.y = 0.3 + Math.sin(time * 2 + index) * 0.1;
                }
            });
        }

        // ========== ì•„ì´í…œ ìˆ˜ì§‘ ==========
        function checkItemCollection(player) {
            const collectionRadius = 0.8;

            gameState.items.forEach(item => {
                if (!item.collected) {
                    const dx = player.position.x - item.position.x;
                    const dz = player.position.z - item.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance < collectionRadius) {
                        collectItem(player, item);
                    }
                }
            });
        }

        function collectItem(player, item) {
            player.score += item.points;
            item.collected = true;
            scene.remove(item.mesh);

            updateScoreUI();

            setTimeout(() => {
                spawnRandomItem();
            }, 500);

            console.log(`Player ${player.playerNum} collected ${item.type}! Score: ${player.score}`);
        }

        function checkAllCollections() {
            gameState.players.forEach(player => {
                checkItemCollection(player);
            });
        }

        // ========== UI ì—…ë°ì´íŠ¸ ==========
        function updateScoreUI() {
            gameState.players.forEach((player, index) => {
                const scoreElement = document.querySelector(`#player${index + 1}Score .score`);
                if (scoreElement) {
                    scoreElement.textContent = player.score;
                }
            });
        }

        // ========== ìŠ¹ë¦¬ ì¡°ê±´ ==========
        function checkWinCondition() {
            gameState.players.forEach((player) => {
                if (player.score >= TARGET_SCORE) {
                    endGame(player.playerNum);
                }
            });
        }

        function endGame(winnerNum) {
            gameState.isRunning = false;

            const message = document.createElement('div');
            message.id = 'winnerMessage';

            const playerColors = ['#ff6b6b', '#4ecdc4', '#95e1d3'];
            message.innerHTML = `
                <h1 style="color: ${playerColors[winnerNum - 1]}">ğŸ‰ Player ${winnerNum} Wins! ğŸ‰</h1>
                <p>Press R to Restart</p>
            `;
            document.body.appendChild(message);

            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'r' && !gameState.isRunning) {
                    location.reload();
                }
            });
        }

        // ========== ê²Œì„ ì´ˆê¸°í™” ==========
        function initGame() {
            addLights(); // ì¡°ëª… ì¶”ê°€
            createFloor(); // ë°”ë‹¥ ìƒì„±
            createBoundaryWalls(); // 4ê°œ ê²½ê³„ ë²½ ìƒì„±, createWall í•¨ìˆ˜ ì‚¬ìš©
            createObstacles(); // ì¥ì• ë¬¼ 3ê°œ, createWall í•¨ìˆ˜ ì‚¬ìš©
            createPlayers(); // í”Œë ˆì´ì–´ì™€ í‚¤ ì„¤ì •
            createInitialItems(15); // ì´ˆê¸° ì•„ì´í…œ 15ê°œ ìƒì„±
        }

        // ========== ê²Œì„ ë£¨í”„ ==========
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            if (gameState.isRunning) {
                updatePlayers();
                animateItems();
                checkAllCollections();
                checkWinCondition();
            }

            renderer.render(scene, camera);
        }

        // ========== ë°˜ì‘í˜• ==========
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ========== ê²Œì„ ì‹œì‘ ==========
        document.getElementById('startButton').addEventListener('click', () => {
            if (!gameState.isStarted) {
                gameState.isStarted = true;
                gameState.isRunning = true;
                document.getElementById('gameTitle').classList.add('hidden');
                console.log('ê²Œì„ ì‹œì‘!');
            }
        });

        // ========== ì´ˆê¸°í™” ë° ì‹œì‘ ==========
        initGame();
        gameLoop();

        console.log('ìš”ë¦¬ ì•„ì´í…œ ìˆ˜ì§‘ ê²Œì„ì´ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!');
        console.log('ê²Œì„ ì‹œì‘ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”!');
    </script>
</body>
</html>
