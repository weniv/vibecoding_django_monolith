# Django 블로그 웹 애플리케이션 구축 가이드

## URL 설계
```
'/' : 홈 페이지
'/about': 소개 페이지
'/contact': 연락처 페이지
'/blog': 블로그 메인 페이지
'/blog/1': 블로그 1번 글 페이지
'/blog/2': 블로그 2번 글 페이지
'/blog/태그명': 특정 태그의 블로그 글 페이지
'/admin': 관리자 페이지
```

## 초기 세팅 (Windows)
```bash
python -m venv venv
.\venv\Scripts\activate
pip install django
django-admin startproject config .
```

## 1. settings.py 설정
```python
# config/settings.py
ALLOWED_HOSTS = ["*"]
```

## 2. 데이터베이스 마이그레이션 및 서버 실행
```bash
python manage.py migrate
python manage.py runserver
```

## 3. main 앱 생성
```bash
python manage.py startapp main
```

## 4. settings.py에 앱 등록
```python
# config/settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main',  # 추가
]
```

## 5. 모델 작성
```python
# main/models.py
from django.db import models
from django.utils.text import slugify

class Tag(models.Model):
    name = models.CharField(max_length=50, unique=True)
    slug = models.SlugField(max_length=50, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def save(self, *args, **kwargs):
        if not self.slug:
            self.slug = slugify(self.name)
        super().save(*args, **kwargs)

    def __str__(self):
        return self.name

class Post(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    is_published = models.BooleanField(default=False)
    author = models.CharField(max_length=100, blank=True, null=True)
    tags = models.ManyToManyField(Tag, related_name='posts', blank=True)

    def __str__(self):
        return self.title

    class Meta:
        ordering = ['-created_at']  # 최신순 정렬
```

* ManyToManyField: Post와 Tag 모델 간의 다대다 관계를 설정합니다. 하나의 게시물은 여러 태그를 가질 수 있고, 하나의 태그는 여러 게시물에 연결될 수 있습니다. 둘 중에 한 쪽에 `related_name='posts'`를 지정하여, Tag 객체에서 해당 태그가 연결된 모든 게시물에 접근할 수 있도록 합니다.
* ForeignKey: 만약 게시물과 작성자(User) 간의 일대다 관계를 설정하려면 ForeignKey를 사용합니다. 이 경우, Post 모델에 `author = models.ForeignKey(User, on_delete=models.CASCADE)`와 같이 작성할 수 있습니다. CASCADE 옵션은 작성자가 삭제될 때 해당 작성자의 모든 게시물도 함께 삭제되도록 합니다. N쪽에 작성하는 코드입니다.
* OneToOneField: 만약 게시물과 상세 정보(PostDetail) 간의 일대일 관계를 설정하려면 OneToOneField를 사용합니다. 이 경우, PostDetail 모델에 `post = models.OneToOneField(Post, on_delete=models.CASCADE)`와 같이 작성할 수 있습니다. CASCADE 옵션은 게시물이 삭제될 때 해당 게시물의 상세 정보도 함께 삭제되도록 합니다. 1:1 관계에서 어느 쪽에나 작성할 수 있습니다.

## 6. 모델 마이그레이션
```bash
python manage.py makemigrations
python manage.py migrate
```

## 7. admin 등록
```python
# main/admin.py
from django.contrib import admin
from .models import Post, Tag

admin.site.register(Post)
admin.site.register(Tag)
```

## 8. 관리자 계정 생성
```bash
python manage.py createsuperuser
leehojun
leehojun@gmail.com
dlghwns1234!
```

## 9. 프로젝트 URL 설정
```python
# config/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("main.urls")),
    # 만약 앱이 여러개면 아래와 같이 추가됩니다.
    # path("blog/", include("blog.urls") # blog 앱에 urls.py가 있어야 합니다.
    # path("shop/", include("shop.urls") # shop 앱에 urls.py가 있어야 합니다.
]
```

## 10. main 앱 URL 설정
```python
# main/urls.py (새로 생성)
from django.urls import path
from . import views

urlpatterns = [
    path("", views.home, name="home"),
    path("about/", views.about, name="about"),
    path("contact/", views.contact, name="contact"),
    path("blog/", views.blog_index, name="blog_index"),
    path("blog/<int:post_id>/", views.blog_post, name="blog_post"),
    path("blog/<str:tag_name>/", views.blog_tag, name="blog_tag"),
]
```

## 11. 뷰 함수 작성
```python
# main/views.py
from django.http import HttpResponse
from django.shortcuts import render, get_object_or_404
from .models import Post, Tag

def home(request):
    return HttpResponse("홈 페이지")

def about(request):
    return HttpResponse("소개 페이지")

def contact(request):
    return HttpResponse("연락처 페이지")

def blog_index(request):
    posts = Post.objects.filter(is_published=True)
    posts_html = "<br>".join([f"<a href='/blog/{post.id}/'>{post.title}</a>" for post in posts])
    return HttpResponse(f"<h1>블로그 메인 페이지</h1>{posts_html}")

def blog_post(request, post_id):
    post = get_object_or_404(Post, id=post_id, is_published=True)
    tags_html = ", ".join([f"<a href='/blog/{tag.slug}/'>{tag.name}</a>" for tag in post.tags.all()])
    return HttpResponse(f"<h1>{post.title}</h1><p>{post.content}</p><p>태그: {tags_html}</p>")

def blog_tag(request, tag_name):
    tag = get_object_or_404(Tag, slug=tag_name)
    posts = tag.posts.filter(is_published=True)
    posts_html = "<br>".join([f"<a href='/blog/{post.id}/'>{post.title}</a>" for post in posts])
    return HttpResponse(f"<h1>'{tag.name}' 태그의 블로그 글</h1>{posts_html}")
```

* Model명.objects.filter(조건): 특정 조건에 맞는 객체들을 필터링하여 QuerySet으로 반환합니다.
* Model명.objects.get(조건): 특정 조건에 맞는 단일 객체를 반환합니다. 조건에 맞는 객체가 없거나 여러 개일 경우 예외가 발생합니다.
* Model명.objects.all(): 해당 모델의 모든 객체를 반환합니다.
* get_object_or_404(Model, 조건): 특정 조건에 맞는 객체를 반환하며, 조건에 맞는 객체가 없을 경우 404 에러를 발생시킵니다.

## 12. 서버 실행
```bash
python manage.py runserver
```

## 13. admin 페이지에서 게시물 및 태그 추가

```
# http://127.0.0.1:8000/admin 접속
# 관리자 계정으로 로그인
# Post, Tag 데이터 추가

# 게시물1
# Title: 첫 번째 블로그 글
# Content: 이것은 첫 번째 블로그 글의 내용입니다.
# is_published: 체크
# 태그: Django, Python

# 게시물2
# Title: 두 번째 블로그 글
# Content: 이것은 두 번째 블로그 글의 내용입니다.
# is_published: 체크
# 태그: 웹개발, Django

# 게시물3
# Title: 비공개 글
# Content: 이 글은 비공개입니다.
# is_published: 체크 해제
# 태그: 비공개
```

## 접속 URL
- http://127.0.0.1:8000/ : 홈 페이지
- http://127.0.0.1:8000/about : 소개 페이지
- http://127.0.0.1:8000/contact : 연락처 페이지
- http://127.0.0.1:8000/blog : 블로그 메인 페이지
- http://127.0.0.1:8000/blog/1 : 블로그 1번 글 페이지
- http://127.0.0.1:8000/admin : 관리자 페이지

## 테스트 데이터 추가
1. http://127.0.0.1:8000/admin 접속
2. 로그인 후 Post, Tag 데이터 추가
3. Post 작성 시 `is_published` 체크
4. Post에 Tag 연결
